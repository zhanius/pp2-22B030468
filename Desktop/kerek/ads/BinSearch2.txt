B, E, G, J. Те самые задачи которые вроде бы никак не подходят под бин поиск, но каким то чудесным образом в этой лаб работе.
Дело лишь в том что по ним можно делать поиск и он отсортирован. А отсортирован он по запросам котоые мы будем делать.
Пример запроса. 
Сколько чисел меньше чем 10 в массиве [1, 4, 10, 43, 5].
Как мы видим тут их 3 [1, 4, 5]. А теперь давайте попробуем увеличить наше число 10 на 11.
И уже ответ 4 [1, 4, 10, 5]. Тааакс. Получается чем в запросе число больше тем больше наш ответ.
Значит по запросам можно запускать наш ШАЙТАН БИН ПОИСК.


E-Jonathan the Farmer
Идеальная задача для примера. Если мы будем спрашивать для координат 0,0 и х, х сколько я смогу овечек взять.
Будем пробовать с х = 5 а потом чуть больше если можем или чуть меньше если не можем взять хотя бы к(как пример). 
То без зазрения совести по нему делаем поиск.
Наш запрос

struct Pasture{
    int x1, x2;
    int y1, y2;
};


int getPasturesCount(vector<Pasture> &pastures, int x) {
    int res = 0;
    for(auto &pasture : pastures) {
        if(pasture.x1 <= x && pasture.y1 <= x && pasture.x2 <= x && pasture.y2 <= x)
            res++;
    }
    return res;
}

А дальше простой поиск по нему

 while(l + 1 < r) {
        int mid = (l+r)/2;
        if(getPasturesCount(pastures, mid) >= k)
            r = mid;
        else
            l = mid;
 }

общий код

#include <bits/stdc++.h>

using namespace std;

struct Pasture{
    int x1, x2;
    int y1, y2;
};

int getPasturesCount(vector<Pasture> &pastures, int x) {
    int res = 0;
    for(auto &pasture : pastures) {
        if(pasture.x1 <= x && pasture.y1 <= x && pasture.x2 <= x && pasture.y2 <= x)
            res++;
    }
    return res;
}

int main() {

    int n, k;
    cin >> n >> k;

    vector<Pasture> pastures(n);
    for(auto & pasture : pastures) {
        cin >> pasture.x1 >> pasture.y1 >> pasture.x2 >> pasture.y2;
    }

    int l = 0, r = 1e9+2;

    while(l + 1 < r) {
        int mid = (l+r)/2;
        if(getPasturesCount(pastures, mid) >= k)
            r = mid;
        else
            l = mid;
    }

    cout << r;

    return 0;
}






G-Santa Jonathan
Очень схожа с пред задачей.
В основном нужно будет спрашивать. Если у меня размер ч... ой размер сумки будет Х то сколько нужно времени мне потратить. 
И если это время о боже меньше чем у нас есть то это число я считаю хорошим. Среди этих хороших чисел мне нужно найти самую меньшую.

Наш запрос
long long getWorkTime(vector<long long> &islands, long long bucketSize) {
    long long timeToWork = 0;
    for(auto i : islands) {
        timeToWork += i/bucketSize;
        if(i%bucketSize)
            timeToWork++;
    }
    return timeToWork;
}


и дальше просто обычный бин поиск и общий код

#include <bits/stdc++.h>

using namespace std;

long long getWorkTime(vector<long long> &islands, long long bucketSize) {
    long long timeToWork = 0;
    for(auto i : islands) {
        timeToWork += i/bucketSize;
        if(i%bucketSize)
            timeToWork++;
    }
    return timeToWork;
}

int main() {
    long long n, f;
    cin >> n >> f;
    vector<long long> islands(n);
    for(long long &island: islands)
        cin >> island;

    long long l = 0, r = 1e18+123;

    while(l + 1 < r) {
        long long mid = (l+r)/2;
        long long timeToSanta = getWorkTime(islands, mid);
        if(timeToSanta <= f)
            r = mid;
        else
            l = mid;
    }
    cout << r;


    return 0;
}



B-Oshiete oshiete yo sono shikumi wo
Канеки ZXC DEAD INSIDE. Наверное самый необычный и в то же время очень обычный. Необычный он тем что запрос очень интересный, но дальше по коду все очень максимально обычно.
Для каждого числа будем спрашивать. Можешь разделить массив на меньше или равно нашему К. Допустим наша сумма должна быть меньше 1e18. То понятно что можем так и слить все в массив 
так и разделить на Н массивов. И явно видем корреляция "чем больше сумма тем меньше колличество массивов"
А в запросе мы будем вычислять для числа Х на сколько массивов можно разделить
long long getBlocksCount(vector<long long> &nums, long long sz) {
    long long cur = 0, res = 0;
    for(auto i : nums) {
        if(i > sz)
            return 1e18+123;
        if(cur + i > sz) {
            res++;
            cur = i;
        } else
            cur += i;
    }
    if(cur)
        res++;
    return res;
}
Все у нас в long long чтобы навсякий не выйти за границы int.
Нуу и после запроса код так же обычный

#include <bits/stdc++.h>

using namespace std;

long long getBlocksCount(vector<long long> &nums, long long sz) {
    long long cur = 0, res = 0;
    for(auto i : nums) {
        if(i > sz)
            return 1e18+123;
        if(cur + i > sz) {
            res++;
            cur = i;
        } else
            cur += i;
    }
    if(cur)
        res++;
    return res;
}

int main() {
    long long n, k;
    cin >> n >> k;
    vector<long long> nums(n);
    for(auto &i: nums)
        cin >> i;
    long long l = 0, r = 1e18+123;
    while(l + 1 < r) {
        long long mid = (l+r)/2;
        long long blocks = getBlocksCount(nums, mid);
        if(blocks <= k)
            r = mid;
        else
            l = mid;
    }
    cout << r;
    return 0;
}


J-Robin Hood stealing the Gold
Запрос здесь такой -> сколько мне нужно потратить времени если крадет Х каждый час. и по нему уже сравнивать
Запросы отсортираны по убыванию. Чем больше он сможет за час тем меньше ему нужно времени. То есть нужно найти первое меньше или равно нашему H по запросу
#include <bits/stdc++.h>

using namespace std;

long long getTimeToWork(vector<long long> &bags, long long sz) {
    long long res = 0;
    for(auto i : bags) {
        res += i/sz;
        if(i%sz)
            res++;
    }
    return res;
}

int main() {

    long long n, h;
    cin >> n >> h;
    vector<long long> bags(n);
    for(auto &i: bags)
        cin >> i;
    long long l = 0, r = 1e18+123;
    while(l + 1 < r) {
        long long mid = (l+r)/2;
        long long timeToWork = getTimeToWork(bags, mid);
        if(timeToWork <= h)
            r = mid;
        else
            l = mid;
    }
    cout << r;
    return 0;
}
